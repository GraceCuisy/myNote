### 原生JS相关
  1. 作用域
    定义: 变量起作用的区域范围
    分类: 全局作用域,局部作用域,块级作用域
    作用: 隔离变量
    全局变量：定义在全局环境当中的就是全局变量（函数外部，全局作用域）
		局部变量：定义在局部环境当中的就是局部变量（函数内部，函数作用域）
    全局变量：在整个程序所有的地方都可以起作用（整个程序当中任何地方都可以操作这个全局变量）；
		局部变量：只能在自己的作用域当中起作用，局部变量只能在函数内部使用，外部不能使用内部的；
  **当局部里面有一个变量没有写var的时候：**
			1、看看这个变量是不是形参，如果是形参，当作局部变量处理
			2、如果这个变量没有带var,同时形参也没有这个变量，接下来看看全局当中是否有这个变量，有就是操作全局变量的值；
			 如果没有这个全局变量，相当于是函数内部和外部都没有定义过这个变量，此时就是在定义一个（全局变量）；
  2.  作用域链
			描述的是变量查找的规则；先从自己的作用域当中去查找，找到就使用，找不到会继续往上级去查找，一直找到全局为止；
		中间如果首先找到就会使用，不再继续，如果没有找到继续往上找，直到找到全局都没有，报错（这个变量未定义*******）！这个查找变量的规则，过程被称作作用域链；

		**作用域链是在函数调用的时候才会有的，定义的时候不存在，作用域是函数定义的时候就已经确定好的；**
		每个执行环境都会有自己独立的作用域链
    作用域链高级
      作用域链是高级存在的,作用域链是使用执行上下文当中的变量对象所组成的链条结构(数组结构); 
      查找的时候其实真正是去自身的变量对象当中查找,如果没有,去上一级执行上下文的变量对象当中去查找,直到找到全局执行上下文的变量对象;函数上一级的变量对象其实是在函数定义的时候就确定好的
    例如: 对于全局执行上下文而言,全局的global变量对象(window对象)就是我的作用域链
  3. 内存分为栈内存和堆内存：特点如下
		栈：栈结构先进后出（FILO） 可以想象成一个桶    栈结构当中开辟的内存，比较小，速度比较 快，操作系统自动分配自动回收；
		堆：堆结构是链表结构，可以随意的在任何位置添加和删除；可以想象成一个链条；   
      堆结构当中开辟的内存，比较大，速度比较慢，
  4. **程序开始执行到结束都做了什么**
			1、程序一开始执行，碰见了全局环境，首先会创建全局环境并且进行压栈，全局代码执行的时候依赖的就是全局环境当中的东西；
			比如 全局变量（全局变量如果存的是基本数据类型，那么这个值是直接存在栈当中的，如果这个变量存的是对象类型（函数、数组）），
                       那么函数和数组是要在堆结构当中开辟自己的空间专门存储(数据本身)的。然后把堆里面这块空间的地址存给栈当中的对应变量；


			2、当程序执行碰到了函数调用；函数是比较特殊，因为它也可以执行；函数执行的时候也要有自己的环境去依赖。
                        因此函数执行也是创建自己的函数环境进行压栈（函数环境一定是压在全局环境之上的），局部变量，是在函数环境当中存在的，
                        只有函数执行，局部变量才会出现。函数执行完成以后，函数环境要弹出栈（销毁归还内存）,局部变量也就不复存在了。


			3、当函数调用完成以后，会继续执行全局代码，一直到所有的代码都执行完成，代表程序执行结束，程序结束的时候，我们的全局环境最后出栈。
  5. 预解析
			程序在代码执行之前会先进行预解析；
			预解析会解析带var的变量和函数
				解析函数优先级比解析变量要高：可以认为解析的时候分为两步，先去解析所有的函数，再去解析所有的带var变量；
				解析过程当中，如果函数重名，会覆盖（后面的函数会把前面的覆盖掉）
					      如果变量重名，会忽略；
				
				解析函数的时候，函数定义方式不同，解析过程也不大一样：
					如果是字面量定义，整个函数都要被提升
					如果是表达式定义，只会提升变量（当作带var变量去提升）；
					function func(){};
					var func = function(){};

				变量如果不带var，变量是不会进行预解析的；只有带var的变量才会进行预解析；
  6. 什么是原型对象:
				原型对象是默认是object的实例对象
				一个函数对象在定义的时候，伴随它出现的另外一个对象就是原型对象；
				函数对象.prototype  显示原型对象   
				实例对象.__proto__  隐式原型对象
				显示原型对象是用来让你操作的
				隐式原型对象是用来让你查找的
			原型对象的作用
				资源共享  节约内存
			原型对象身上添加的东西是为实例化对象来服务的,而不是构造函数，构造函数没办法获取
			
	7. **原型链**
		  (1)描述的是对象在查找属性或者方法的过程
			(2)实例化对象在找属性的时候，先从自身去找看有没有这个属性，如果有，直接使用这个属性的值，如果没有，会继续顺着这个对象的
			隐式原型对象（__proto__）找到这个对象的原型对象（和它的构造函数的显式原型对象是同一个），看看原型对象是否存在这个属性，
      如果有就使用原型对象当中的这个属性值，如果还没有，再去找原型对象的隐式原型对象（默认就是Object显式原型对象），
      找到以后去看看有没有这个属性，如果有就使用这个属性值；如果没有就返回undefined(代表已经找到顶了)；
      (3) **终极原型链**
         Object再牛逼也是一个对象,肯定是有构造函数把它new出来,它本质又是函数,函数是由Function new出来的
         所以原型链上的构造函数都是由Function new 出来的
         Function 默认是自己造的自己, Function才是爸爸
         当Function new出Object时,又把Object作为了所有东西的顶级对象
         判断题
          Function instanceof Object true
  8. new关键字实例化对象的过程
    开辟内存空间
    让构造函数内部的this指向该内存地址
    执行函数代码
    生成实例对象返回 最后把这个实例化对象的对象地址返回
  9. this指向
    this其实是一个关键字,是一个在全局执行环境和函数执行环境当中的一个内置变量
    this通常存在于函数或者方法内部,函数或方法的执行者是谁,this就指向谁
    this指向谁就看谁调用,this是在调用的时候才确定的
    (1)普通函数调用 this指向window
    (2)方法调用的时候,一般this指向的就是这个方法的对象
    (3)构造函数的this指向实例化对象
    (4)事件回调函数当中的this指向事件源
    (5)call和apply可以灵活的改变this的指向
    (6)箭头函数里面是没有this的,它只看定义时,拿的是它外部的this,就看外部有没有嵌套函数,如果有,外层函数的this就是内部箭头函数的this,如果没有,this就是window
    (7)自定义迭代器,函数里面的this指的是for of遍历的对象或数组
  10. **闭包Closure**
    [[scopes]] 指的作用域链  以fn1为例,它的scopes里存放的有全局global对象和上一个函数对象closure
    闭包描述: 闭包是一个引用关系,最终用一个对象去描述,但是是系统形成的,咱们无权操作,引用关系是内部函数引用外部函数变量的关系
    在调试工具中也能看到,scope 和[[scopes]]中
    **独立的闭包机制**
      外部的函数执行上下文以及你生成的函数形成了一套闭包机制,都死不了,并且只要你敢调用里面的函数
      必须拿的是外部函数执行环境中的变量,因为里面函数是外部函数调用生出来的
      只要外部函数敢调用一次,我就生一个新的闭包机制, 每一个闭包机制之间是独立的,都是各自的
    1.如何产生闭包(条件)?
      *函数嵌套
        *内部函数引用外部函数的局部变量
      *使用（调用）外部函数
      并且内部函数也要调用或者引用（针对谷歌）（因为部分浏览器会对内部函数做优化，内部函数不使用或者不引用，相当于没有）；
	  2.闭包到底是什么?
  	 	* 理解一: 闭包是嵌套的内部函数(绝大部分人)
  	 	* 理解二: 包含被引用变量(外部函数)的对象(极少数人)
  	 	* 理解三： 所谓的闭包是一个引用关系，该引用关系存在于内部函数中，引用的是外部函数的变量的对象(深入理解)
    3、常见的闭包
      1.将函数作为另一个函数的返回值
      2.将函数作为实参传递给另一个函数调用
      3.使用闭包实现私有方法操作独立的私有属性
    4、闭包的作用
      1.延长外部函数变量对象的生命周期
      2.让函数外部可以操作(读写)到函数内部的数据(变量/函数)
      3.注意： 浏览器为了性能后期将外部函数中不被内部函数使用的变量清除了
    5、闭包的生命周期
      1.产生: 在嵌套内部函数定义完时就产生了(不是在调用)
      2.死亡: 在嵌套的内部函数成为垃圾对象时
    6、自定义模块	
        * 具有特定功能的js文件
        * 将所有的数据和功能都封装在一个函数内部(私有的)
        * 只向外暴露一个包信n个方法的对象或函数
        * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
      使用自调用和不使用自调用函数区别
    7、闭包的缺点和解决(内存泄漏和内存溢出)
      内存泄漏 ： 内存无法释放；
      内存溢出 ： 内存被撑爆；
      f = null;  解决方式；
  11. **面向对象**
    1. 继承
      第一种：原型继承    （用来继承方法的）
			让子类的原型是父类的一个实例
      Teacher.prototype = new Person();
			//为了让原型对象成为真正的原型对象，手动添加构造器constructor
			Teacher.prototype.constructor = Teacher;
      第二种:借用构造函数继承
      function Teacher(name,age,gender,height){
				//第二种：借用构造函数继承 （用来继承属性的）
				Person.call(this,name,age,gender);	
				this.height = height;
			}
      第三种：组合继承 （方法和属性一起继承）
    2. 多态: 指根据我传入的参数不同,我的函数的功能不同,状态不同
			//方法重写和方法重载都是面向对象多态的表现形式：（重写父类的方法）本质上就是给自己添加自己的和父类同名的方法；
      方法重载:就是指根据我传入的参数不同,函数呈现出不同的功能
      Teacher.prototype.eat = function(flag){
				if(typeof flag == 'number'){
					console.log('吃肉');
				}else if(typeof flag == 'boolean'){
					console.log('吃菜');
				}else{
					console.log('减肥');
				}
			}
    3. class类
      如果要继承,必须属性和方法一起继承,写了extends就自动把父类的方法继承过去了
      此时子类里面写了constructor之后,必须写super去继承父类的所有属性,不要也强加给你
      a=10;
      static b=200
      扩展react类定义
        所以react中都是用复制语句
      	1.changeWeather是放在原型上的。
        2.changeWeather中的this是undefined
        3.由于changeWeather不属于react生命周期函数。
        备注：在组件类中，所有非react生命周期函数中的this都被react更改了this，变为了undefined。

### css和html
  1. css盒模型
    (1)盒子基本三属性: 宽度,高度,背景色
    div是没有语义的大盒子,span是没有语义的小盒子
    (2)显示模式
       块级显示模式: 设置宽高起作用,独占一行,在不设置宽度时,宽度和父元素的宽度一样
       块元素: div, h1-h6,hr,table,ul,ol,li,dl,dt,dd,form,p
       行内显示模式:设置宽高不起作用,一行可以有多个,宽高是被内容撑开的
       行内元素:span,b,strong,i,em,u,ins,s,del,a,label
       行内块显示模式:设置宽高起作用,一行可以有多个
       行内块元素:img,表单标签,input
    (3)显示模式转换
      转换为行内块: display: inline-block
      转换为块元素: display:block
### 移动端
  1. DPR像素比: 物理像素个数/设备独立像素
  2. 在移动端的布局视口大小默认是980css像素大小
  3. 理想视口只是布局视口的别名: 当布局视口的宽度等于设备独立像素的宽度时,
     我们称此时的布局视口是理想视口
  4.	为什么做viewport适配
    a)	手机厂商在生产手机的时候大部分手机默认页面宽度为980px
    b)	手机实际视口宽度都要小于980px，如: iphone6为375px
    c)	开发需求： 需要将980的页面完全显示在手机屏幕上且没有滚动条
    实现：
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
  5.  rem适配
      1.	为什么做rem适配
      a)	机型太多，不同的机型屏幕大小不一样
      b)	需求： 一套设计稿的内容在不同的机型上呈现的效果一致，根据屏幕大小不同的变化，页面中的内容也相应变化
      2.	实现：
      function remRefresh() {
      let clientWidth = document.documentElement.clientWidth;
        // 将屏幕等分10份
          let rem = clientWidth / 10;
          document.documentElement.style.fontSize = rem + 'px';
          document.body.style.fontSize = '12px';
      }

      window.addEventListener('pageshow', () => {
        remRefresh()
      })
      // 函数防抖
      let timeoutId;
      window.addEventListener('resize', () => {
        timeoutId && clearTimeout(timeoutId);
        timeoutId = setTimeout(() =>{
          remRefresh()
        }, 300)
      })

3. 第三方库实现
	lib-flexible + px2rem-loader


