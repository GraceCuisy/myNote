### 描述一下你的项目
### css和js基础过一遍
### 移动端1像素边框实现
    媒体查询 加上transform scaleY()
### 说说从输入url到看到页面发生的全过程
  1. 大体流程: 从浏览器输入url,浏览器向DNS服务器发送请求,进行域名解析,
     浏览器拿到解析后的ip地址加上请求参数向服务器发送请求,拿到对应的资源解析渲染到页面上
     DNS解析 ===> TCP三次握手===>发送http请求===>服务器处理请求并返回HTTP报文==>浏览器解析渲染页面==>断开连接(TCP四次挥手)
  2. 基本概念:
    url:统一资源定位符,用于定位互联网上的资源,俗称网址http://www.w3school.cn
    协议号, 域主机,域名,端口号, path路径, filename文件名称
    域名解析: 浏览器并不能通过域名找到对应的服务器,所以需要域名解析,把域名解析成IP地址,
    域名是IP地址的乔装者,为了更方便人们记忆
    IP地址: 互联网协议地址,32位
    http请求报文: 行头体
      请求行: 请求方法 URL 协议版本
      请求头: 包含请求的附加信息,包含许多有关的客户端环境
      请求体: 可以承载多个请求参数的数据,name=tom&password=1234&realName=tomson
    http响应报文:行头体
      响应行: 协议版本 状态码 状态码描述
      响应头: 响应报文的附加信息
      响应体: 服务器返回的响应数据
  3. 浏览器如何通过域名去查询url对应的IP呢?
     浏览器缓存中去找
     操作系统缓存
     路由缓存
     ISP的DNS服务器
     根服务器
  4. 浏览器向服务器发送HTTP请求阶段: TCP三次握手,http请求响应信息, 关闭TCP连接
    TCP三次握手:
          浏览器发起,告知服务器我要发送请求了
          服务器发起,告诉浏览器我准备接受了,你赶紧发送吧
          由浏览器发起,告诉服务器,我马上就发了,准备接受吧
  5. 三次握手结束后, 开始发送http请求报文, 服务器处理请求报文返回http响应报文, 
     浏览器拿到响应文本HTML后,解析渲染页面
  6. 浏览器解析渲染页面的流程
    (1)根据HTML解析出DOM树, DOM树解析的过程是一个深度优先遍历的过程, 即先构建当前节点的所有子节点,再构建下一个兄弟节点, 中途如果碰到script标签,会先执行文本
    (2)根据css解析生成css规则树
      解析css规则树时,js执行将暂停直至css规则树就绪.
      浏览器在css规则树生成前不会进行渲染
    (3)结合DOM树和css规则树, 生成渲染树
    (4)根据渲染树计算每一个节点的信息(布局)
      布局: 通过渲染树中的渲染对象的信息,计算出每一个渲染对象的位置和尺寸
      回流: 在布局完成后,发现了某个部分发生了变化影响了布局,那就需要倒回去重新渲染
    (5)根据计算好的信息绘制页面
      绘制阶段: 系统会遍历呈现树, 将内容显示到屏幕上
      重绘: 意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了
      回流: 一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
      回流的成本开销要高于重绘,而且一个节点的回流往往会导致子节点及同级节点的回流
      什么会引起回流: dom结构改变比如删除了某个节点/ render树变化, 比如减少了padding/ 窗口尺寸发生变化/ 获取某些属性引起回流(offset,scroll,client,width,height)/ 改变字体大小会引起回流
  7. 断开连接: 当数据传送完毕,需要断开TCP链接,此时发起TCP四次挥手
      第一次: 浏览器发起的,发送给服务器,我请求报文发送完了,你准备关闭吧
      第二次: 由服务器发起的,告诉浏览器,我请求报文接收完了,我准备关闭了,你也准备吧
      第三次: 由服务器发起,告诉浏览器,我响应报文发送完了,你准备关闭吧
      第四次:由浏览器发起,告诉服务器,我响应报文接收完了,我准备关闭了,你也准备吧
### h5的本地存储可以用来做什么? Webstorage和cookie,session区别?
  1. h5的本地存储是指localStorage和sessionStorage
  2. 会话控制
     HTTP协议是一个无状态的协议，它无法区分多次请求是否发送自同一客户端。
     而我们在实际的使用中，却又大量的这种需求，我们需要通过会话的控制来解决该问题
  3. **cookie**
    cookie本质是一个存储在浏览器的文本，随着http请求自动传递给服务器。
    也可以说cookie是一个头（请求头/响应头）：
    服务器以响应头的形式将Cookie发送给浏览器
    浏览器收到以后会自动将Cookie保存
    浏览器再次访问服务器时，会以请求头的形式将Cookie发回(浏览器会自动携带cookie)
    服务器就可以通过检查浏览器发回的Cookie来识别出不同的浏览器
    **cookie的不足**
    各个浏览器对cookie的数量和大小都有不同的限制，这样就导致我们不能在Cookie中保存过多的信息。一般数量不超过50个，单个大小不超过4kb。
    cookie是由服务器发送给浏览器，再由浏览器将cookie发回，如果cookie较大会导致发送速度非常慢，降低用户的体验。
    **Session**
    Session 是一个对象，存储特定用户会话所需的属性及配置信息
    **session运作流程**
    我们可以在服务器中为每一次会话创建一个对象，然后每个对象都设置一个唯一的id，并将该id以cookie的形式发送给浏览器，然后将会话中产生的数据统一保存到这个对象中，这样我们就可以将用户的数据全都保存到服务器中，而不需要保存到客户端，客户端只需要保存一个id即可。
    **cookie 和 session的区别**
      1)	存在的位置：
      cookie 存在于客户端，临时文件夹中
      session 存在于服务器端，一个session域对象为一个用户浏览器服务
      2)	安全性：
      cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放
      session存放于服务器中，所以安全性好
      3)	网络传输量：
      cookie会传递消息给服务器
      session本身存放于服务器，但是通过cookie传递id，会有少量的传送流量
      4)	生命周期(以20分钟为例)：
      cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束
      session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁；但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期；关机会造成session生命周期的结束，但是对cookie没有影响
      5)	大小：
      cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存50个cookie
      session 保存数据理论上没有任何限制
  4. **axios跨域请求携带cookie**
      axios和jQuery在同域ajax请求时会带上cookie, 跨域请求不会, 
      跨域请求需要设置 withCredentials 和服务端响应头
      axios.defaults.withCredentials = true;
      res.set("Access-Control-Allow-Origin", "http://localhost:9528");
  5. cookie的应用场景：
    （1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。
　　（2）保存上次登录的时间等信息。
    （3）保存上次查看的页面
    （4）浏览计数
  6. Session的应用场景
    用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。
　　（1）网上商城中的购物车
　　（2）保存用户登录信息
　　（3）将某些数据放入session中，供同一用户的不同页面使用
　　（4）防止用户非法登录
  7. localStorage和sessionStorage的存储数据大小一般都是：5MB
    应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录
    webstorage可以用于组件间通信
  8. WebStorage的优点：
    (1)存储空间更大
    (2)节省网络流量
    (3)快速显示
    (4)安全性 不用像cookie一样担心截获,但是存在伪造问题
### js的数据类型
    基本数据类型: 数字,字符串,布尔值,undefined,null
    引用数据类型: 对象,数组,函数
### 数组去重的几种方式
    (1)利用indexOf()方法去除
    (2)Set去重方案1：遍历 for of 
    (3)Set去重方案2（使用数组方法Array.form()
       (Array.from(); 能够把伪数组，集合转成数组类型，这个方法配合上Set集合就刚好符合我们的需求)
    (4)使用es6展开运算符...
       let s1 = new Set(arr); 
        return [...s1]
### 在js中为什么需要原型链
  构造函数的所有实例都可以访问构造函数原型中的方法和属性。
  也就是把共有的东西统一存放到一个共享空间。这样可以避免相同函数重复声明，减少空间占用，节省内存。
### 事件总线 就是vm对象 原理就是给同一个vm对象绑定事件和触发事件
### 前后端通信的几种方式
    ajax
    EventSource--服务器端推送事件
    WebSocket--客户端与服务器的双向长链接通信
### http请求你了解过吗? 了解过
  1. HTTP协议也叫超文本传输协议, 是一种基于TCP/IP的应用层通信协议
  2. HTTP协议规定了两方面内容:
    客户端向服务器发送数据, 称之为 请求报文
    服务器向客户端返回数据,称之为响应报文
  3. http请求报文包含四部分
    请求行   请求头  空行  请求体
    请求行   GET https://www.baidu.com/s?wd=haha HTTP/1.1
    请求行包括: 请求方法 协议 域名 服务器路径部分 请求参数 协议版本号
    请求头的格式都是固定的: 头的名字: 头的值
    * host                      主机名
    * Connection: keep-alive    连接设置(保持连接)
    * Cache-Control: max-age=0  缓存(max-age=0 不缓存)
    * Upgrade-Insecure-Requests 告知服务器,客户端支持发送 HTTPS 请求
    * User-Agent                简称 UA , 客户端标识
    * Accept                    设置客户端浏览器所接受的数据类型
    * Accept-Encoding           设置客户端所接受的压缩方式
    * Accept-Language           设置客户端接受的语言
    * Cookie                    饼干
    请求体: post请求携带的请求参数
  4.  http响应报文包含四部分
    响应行 响应头 空行 响应体
    `HTTP/1.1      200       OK
    协议版本      状态码     状态字符串`
    响应头 格式和请求头一样, 头名:头的值 响应头的名字是可以自定义的
    常见响应头: 
    * Content-Type      告知客户端响应体的数据格式
    * Date              时间
    * Expires           失效时间
    * Strict-Transport-Security   客户端必须使用 HTTPS 协议来访问服务器
    * X-Ua-Compatible   告知客户端以最新的 IE 版本来解析网页  
    * Content-Length    请求体的数据长度
    响应体: 服务器返回给客户端的数据,可以自定义
  5. 响应状态码
    响应状态码是服务器对结果的标识，常见的状态码有以下几种：
    - 200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；
    - 301：重定向，被请求的旧资源永久移除了（不可以访问了），将会跳转到一个新资源，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址；
    - 302：重定向，被请求的旧资源还在（仍然可以访问），但会临时跳转到一个新资源，搜索引擎会抓取新的内容而保存旧的网址；
    - 304：（Not Modified）请求资源未被修改，浏览器将会读取缓存；
    - 403：forbidden 禁止的
    - 404：请求的资源没有找到，说明客户端错误的请求了不存在的资源；
    - 500：请求资源找到了，但服务器内部出现了错误；
### nodeJs你接触过吗?
    Node.js是一个基于Chrome V8引擎的js的运行环境, 是一个应用程序
    Node.js的作用:
    解析运行JS代码
    操作系统资源, 如内存,硬盘,网络
    在nodejs环境下不能使用 BOM 和 DOM ，也没有全局对象 window，全局对象的名字叫 global
### 在js当中添加事件的方式有几种?
    on  addEventListener
### 你对promise了解多少?  async 和await

### 服务器端渲染你听过吗
### WebSocket你了解过吗
### 写一个检查手机号码的正则表达式
### 跨端开发有几种解决方案
  1. uni-app Taro  chameleon  WePY  mpvue
  2. 只从支持端的数量来看，Taro 和 uni-app 以六端略微领先（移动端、H5、微信小程序、百度小程序、支付宝小程序、头条小程序），chameleon 少了头条小程序紧随其后。
  H5 方面，chameleon 同样是由多态协议实现支持，uni-app 和 Taro 则是都在 H5 实现了一套兼容的组件库和 API。
  mpvue 和 WePY 都提供了转换各端小程序的功能，但都没有 h5 和移动端的支持。
  3. uniapp
    (1)前端福音:uni-app是一个使用Vue.js开发所有前端应用的框架，支持Vue语法 + 小程序标签/API
    (2)跨终端： 开发者编写一套代码，可发布到iOS，Android，H5，以及各种小程序（微信/支付宝/百度/头条/ QQ /钉钉/淘宝） ，快应用等多个平台
	  (3)出身名门: DCloud 国产
### react是如何工作的?
### 快速排序算法(面试中算法题)
### 浏览器动画效果实现
### 延迟加载有几种方式( import路由懒加载)
### 深拷贝和浅拷贝你怎么实现的, 浅拷贝和深拷贝定义
### js里面的内存管理?
    内存分为栈内存和堆内存
    但是在js当中所有的内存都属于堆内存, 然后在堆内存中又分为栈结构和堆结构
    栈: 桶状,先进后出
    堆: 链条式,先进先出
### js垃圾回收机制
### bootstrap是怎么进行适配呀?
### 你之前怎么进行适配的?
### 你用moogoose做过什么? moogooseDB存储的数据类型是怎么样的?
### css中的选择器有哪些?
### 实现一个元素居中几种方式
### 什么时候用到vuex,vuex的插件,vuex的API
### 浏览器缓存,强缓存和协商缓存
### webpack的loader和plugins的区别
### es6和commonjs
### vuex和redux的区别
### 浏览器内核
### 你对模块化的理解
### 浮动和定位
### 行内元素设置margin和padding生不生效
  1. 行内元素是否具有盒子模型
      行内元素同样具有盒子模型
  2. 行内元素的padding,margin是否无效
      行内元素的padding-top bottom margin-top bottom 属性设置是无效的
      行内元素的padding-left, right margin-left right 属性设置是有效的
      行内元素的padding-top,padding-bottom从显示效果上是增加的,但其实设置的是无效的
      并不会对他周围的元素产生任何影响
### 线程和进程的区别?
### vue的源码你看过吗
### TS你接触过吗?
### 轮播图自己实现过程
### 你做的体检宝是一个什么样的业务模式
### 我在浏览器端播放视频使它两倍速播放
### this指向
### ajax同步和异步的区别
### 冒泡排序和快速排序
### 宏任务和微任务深层原理 script标签就是宏任务
### jQuery
### 小程序生命周期


# 京东外派 电话面试题
  进入一个大的环境接触的东西是你在小公司里面接触不到的
    你接触vue多长时间
  ### 你项目中是如何使用vue全家桶的
  ### 你之前碰到过哪些比较难解决的问题
  ### 插槽是用来做什么,作用域插槽, 你自己用来实现过什么功能
  ### 过滤器
  ### 自定义指令 用来做权限控制
      比如说实现一个类似于v-show或者v-if的指令,但是v-if里面只能传true或者false,
      如果我们想传一个字符串进去作为条件判断 就需要自定义指令

  ### js混合
  ### 遍历数组的方法
  ### 10个数组最快速的方式合成一个数组
      [...arr,...arr1,...arr2]
  ### 你之前如何实现的深浅拷贝, 用的哪些方式


