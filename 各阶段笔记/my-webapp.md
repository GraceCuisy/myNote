### 移动端浏览器不支持模板字符串
### 移动端看不见打印日志

### 移动端对字体大小没有限制
   在chrome浏览器中能渲染的字体最小是12px
   但是移动端浏览器没有字体大小的限制
### 让图片和一个块元素对齐
使用vertical-align:middle 和margin的结合使用 
### 行内块(inline-block)元素之间的3像素空隙怎么解决
    3像素空隙是由于代码换行导致的,
    解决方法:将包裹行内块元素的font-size设置为0,
### 图片的位图像素,
    图片在渲染的时候,默认的css像素的个数就是拿的位图像素的尺寸
    当一个位图像素与一个物理像素一一对应时,图片才能完美清晰的展示
    给一个位图像素是400*600的图片设置css像素为4000*8000, 此时图片会严重失真,(在pc端:相当于用400*600个位图像素去填充4000*8000个物理像素, 每一位图像素都被放大了很多倍,所以图片失真)
### 在pc端 1物理像素=1css像素 等价的
### 为啥要把适配的代码写在一个匿名自调用函数中,防止受外面变量的污染
### 使用viewport的系统缩放布局的理解
   1. 目的:将所有设备的布局视口,调整为设计图的尺寸
   2. 网上截取他人理解
    缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。
  3. 理想视口也是布局视口,是在布局视口等于设备独立像素视口时,布局视口的别称
    在iphone上,理想视口是375px;

例: initial-scale=0.5
   理解:页面首次被显示的布局视图参照于理想视口的缩放比例
   通俗来说: 缩放之前,一个页面的理想(布局)视图宽度是375个像素, 1像素代表的宽度缩小一半,同样达到理想视图的宽度需要2倍的像素个数, 所以此时的布局视图宽度为750个像素
   对于iphone6的理想布局视口是375px,此时理想布局375px代表的**实际宽度**就定死了 
   0.5是缩小操作, css像素的面积变小!!  就是把之前代表1px的东西的面积缩小了一半,此时需要一倍的css像素点才能组成之前同样的宽度, 所以此时的布局视口是750px 
   注意:**而我们通常说的布局视口是700px, 700是css像素个数** 
### 注意: width=device-width 和initial-scale系统缩放不能同时存在,会有冲突,
        同时存在时,取较大的值作为布局视口的宽度
### 视口和css像素都是浏览器的概念,屏幕没有这两个概念
    由于物理像素，设备独立像素，像素比都是设备屏幕中的概念与浏览器没有一点关系，在设备出厂时这些参数就定了。
    在pc端,浏览器只有一个视口,默认是与屏幕一样大的,在pc端不用考虑视口
### 视觉视口
   *决定用户能看到什么*
   在移动端经常做一些放大和缩小操作
   如果不考虑放大和缩小的操作,可以不用考虑视觉视口
### 用户的放大 和 缩小 操作是不会影响移动端页面的布局的!!!
      布局视口的尺寸有没有变?  不会改变布局视口的尺寸!!!;在移动端如果在进行缩放操作时;
      改变了布局视口的尺寸,那么整个网站的布局是需要重新绘制的!!特别耗电好流量!!!

      放大的是css像素的面积!!!  视觉视口中包含的css像素的个数变少
      缩小的是css像素的面积!!!  视觉视口中包含的css像素的个数变多
### 移动端用户放大操作和移动端系统放大操作, pc端放大操作总结
   移动端用户放大操作:
      移动端考虑到耗电和耗流量的问题, 用户在放大和缩小操作时, 布局视口的尺寸是没有变化的
      布局视口是375px, 用户放大了,放大的是css像素的面积, 但布局视口仍然是375px, 只能放大了css像素面积的375px看起来更大, 但是页面布局不会改变
      以像素个数来衡量视觉视口的话, 视觉视口内包含的css像素的个数变少,所以可以说视觉视口变小了
      但视觉视口肉眼可见的区域大小是没有变化的
   移动端系统放大操作:
      移动端系统放大和pc端放大操作都是有一个参考的宽度尺寸的
      移动端系统放大操作: 是参照与理想视口的,缩放之前,一个页面的理想(布局)视图宽度是375个像素, 1像素代表的宽度缩小一半,同样达到理想视图的宽度需要2倍的像素个数, 所以此时的布局视图宽度为750个像素 
      以像素个数来衡量视觉视口的话, 视觉视口内包含的css像素的个数变多, 所以视觉视口变大
   pc端放大操作:
      pc端只有一个视口, 浏览器可见区域的宽度
      放大了一个css像素面积,一个css像素面积变大了, 同样宽度下能放的css像素个数变少了, 页面布局会发生改变
   **总结**:  放大的都是1css像素的面积 ==> 影响了**同样宽度**放置的css像素的个数==>影响布局和视觉视口大小
    用户放大 ==> 布局视口不变 ==> 视觉视口变小
    系统放大 ==> 布局视口变小 ==> 视觉视口变小
    pc端放大 ==> 一行放置的元素个数变少 ==> 页面布局发生改变
### 太大的元素
   太大的元素
   太大的元素:当布局视口内的元素大于整个布局视口后,有些浏览器会选择让整个视觉视口包住这个太大的元素,照理来讲要出现横向滚动条.加上完美视口之后 几乎所有的浏览器都不会包住这个太大的元素 而是出现横向滚动条
   完美视口: 
   <meta name="viewport" content="width=device-width,initial-scale=1.0">

### 写移动端页面不做适配的情况下:
   设计图上标识的像素是位图像素
   要想让图片完美展示 1位图像素=1物理像素
   所以此时 每个元素的css像素大小= 设计图上标识的像素/2
### 不做适配的情况下
   称为流体加固定布局, 如果元素没有超过理想视口的宽度时,没有问题, 超过会有问题
### 两种适配方案的理解  使布局视口=设计图宽度
   **适配的意义**: 让页面布局(比例)在每个设备上一样 页面在不同设备上的布局就不会变化
   1.viewport的系统缩放
      得到当前屏幕下理想视图的宽度
      得到设计图的宽度
      得到系统缩放比例 
      设置回meta标签
   2.rem的方式
      各种设备的布局视口都看成16rem  设计图的宽度也看成16rem
      在less中定义一个变量@rem=设计图宽度/16
      每个元素转化为rem  每个元素尺寸/@rem
### 适配与非适配理解
   不做适配时: 
      为了让图片最佳展示 1位图像素=1物理像素
      在像素比为2的情况下:  每个元素的css像素=每个元素的位图像素/2 (写代码时设计稿上值要除以2)
   使用rem适配时: 此时图片仍然是最佳展示
      布局视图宽度等于 设计图尺寸
      在ipone6的手机上 
      布局视图        375css像素  16rem   1rem对应 375/16的css像素 将值设置给html的字体大小
      设计图 位图像素  750位图像素  16rem  @rem=750/16rem  1rem应该占据多少的位图像素
      1rem对应23.43个css像素
      1rem对应46.875个位图像素 1位图像素= 1/46.875rem
      设计图上的128位图像素对应的rem值  128*1/46.875rem  => 128/46.875 rem
      然后在less中解析时 128/46.875rem 等于 128/46.875*23.43 个css像素
      最终在less中元素解析的css像素值是: 64px
      总结:  750位图像素=16rem               16rem=375个css像素
            把设计图中元素转化为rem形式       设置html字体为1rem对应的css像素值
                                          系统在解析less时把每个元素的rem值转化为对应的css像素
                  间接完成了 从位图像素==>css像素
      1rem左手边对应合适的css像素 右手边对应着合适的位图像素 实现了从位图像素到css像素的转换
      10y=9x  x=10/9y
### 如何使用真机测试
 #### fis3的使用
      1.fis3是百度开发者的一款工具,相当于百度的webpack,前端构建工具,可以做代码的部署
      2.通过npm i fis3 -g
      fis3-v
      fis3 server open :打开fis3内置的静态资源服务器的目录
      fis3 server start: 启动服务器,默认监听8080端口
 #### 手机要和电脑在同一个网段上, 用手机去链接电脑WiFi(360免费WiFi)
      ipconfig 查看当前电脑的ip
      ipv4的地址  加上端口号:8080
### 无缝滑屏相关
   1. 1/2跳转
   2. 使用定位实现动画性能还是比较低的,尤其在移动端,不推荐使用定位实现动画效果
      可以使用2D变换实现动画
   3. **注意offsetLeft与translate的坑**
      元素的offsetLeft永远记录的永远都是left的距离的
      注意 offsetLeft是没有办法记录transform走了多少距离的
   4. **transform的操作**,如果直接通过style.transform去操作,非常不容易操作,扩展性差
      你要随时考虑之前transform写了啥,加在这次操作上
      所以我们考虑定义一个操作transform的库
   5. **循环定时器的时候套路** 
      在设置定时器之前先清除一次
      一般都会把定时器放在一个函数内部,在使用之前先清除掉自己,防止没必要的多次调用
   6. 自动轮播时,解决第二组图片第4张到第5张,动画消失的问题
      1).代码的执行是非常快的,从第8张图跳到第9张图片的css还没渲染,过渡已经被设置成空了
      2). 使用transitionend
   7. 自动轮播的前提是支持无缝
   8. 让用户自己去选择是否自动轮播
   9. 竖直方向滑屏防抖动
      根据三角形原理,看横向滑动多,还是纵向滑动多
      y轴方向滑动直接return掉
      定义两个防抖动需要的变量
   **业界关于防抖动的默认规则**
      判断用户上来的首次滑屏方向 如果是y轴方向,那以后不管怎么滑动都不会触发滑屏逻辑
      判断用户上来的首次滑屏方向 如果是x轴方向,那以后不管怎么滑动都会触发滑屏逻辑
### 前端工程师画动效的时候必须要掌握的技巧
   异步的思想 渲染是滞后的
   代码执行是非常快的,界面的渲染是滞后的
### 编程小技巧:
   当你把一个数据加到节点的属性,基本上可以跨方法使用
### 移动端浏览器不太支持ES6语法,尽量使用ES5的语法
### 移动端看不见打印日志
### click事件在移动端要基于touchstart
### 写行内块元素时,空格导致了行内块元素有3像素留白,给它的父元素设置font-size:0;可以解决问题

### 可拖动的导航相关
   1. 橡皮筋效果
      touchmove的触发是非常频繁的,每隔1-2px就会触发一次
      橡皮筋效果原理: 手指滑动相同的距离,但这个距离对应的元素实际动的距离越来越小, 所以要乘以一个一直变小的值
   2. 快速滑屏: 求手指离开时的速度
   3. 快速滑屏与橡皮筋效果的冲突 贝塞尔曲线的使用
      快速滑屏的橡皮筋效果要借助贝塞尔曲线
      判断是正常滑屏松的手,还是橡皮筋效果时松的手
   4. 快速滑屏bug之一:
      快速滑屏一次之后,点击都会滑一段距离,原因计算speed速度的两个相关变量没重置
      优化点2: 只有滑动速度足够快的时候,才触发快速滑屏
### 记得每次重置变量时,分母上不要出现0,否则计算出来的值是NaN
### 3D硬件加速
   操作:设置translateZ=0;
   3D硬件加速是不会触发重绘重排的,但是在chrome最新版还是重绘重排,所以我们需要把这个元素层级调高
### 关于动态生成的节点:获取宽高:
   当你项目中遇到一些动态生成的节点时,而且要获取这些节点的位置尺寸这种信息时,一定要长个心眼,最好把获取操作放到一个异步的逻辑中
### 关于this指向
   在框架中函数由你定义,不由你调用时,this指向看文档,框架作者会指明this指向
   你定义,你调用, this指向看调用的方式
### webstorm
   webstorm里面写的代码在浏览器打开呈现效果也是要开启服务器的,是webstorm在你电脑上部署的服务器
### 命名空间的概念
   在全局加变量时,相关变量统一加到一个对象上,把这个对象添加到window上,避免污染window
### 移动端的touchmove触发非常频繁,1-2像素就触发一次

### 组件化思想
   一般来说一个组件的尺寸,位置信息都应该让外部使用时指定